My Problem solving techniques:

Note: While solving any problem always handle corner cases.

------------------
1) BINARY SEARCH
------------------
i) you want to search something / target / missing value etc
ii) changing order of the input doesnt affect the solution
iii) linear searching is clearly visible
iv) think about sorting
v) think of binary search

------------------
2) STACK
------------------
i) you see two loops in brute force
ii) inner is dependent upon outer
iii) ups and downs(dips) in a graph
iv) you want to retain something by eliminating some items (maybe in certain order)

------------------
3) HEAP (PRIORITY QUEUE)
------------------
i) K'th largest/smallest 
ii) there is a feel of sorting (nlogn) we can reduce it to nlogk
iii) you want to retain k largest elements, then use min heap 
iv) you want to retain k smallest elements, then use max heap 
v) dont keep more than k elements in heap, just remove them accordingly(min,max)

------------------
4) Array
------------------
i) Count sort 
ii) Two pointer
iii) stack 
iv) hashmap, hashset
v) binary search, linear search
vi) GREEDY approach
vii) sliding window
viii) prefix,suffix sum array
------------------
4) Recursion
------------------
i) backtracking
ii) quick sort
iii) divide and conquer
iv) memoization, DP 

------------------
5) String
------------------
i) remember every inbuilt methods like (substring, indexOf)
ii) use StringBuilder for all modification operations and remember methods like reverse, deleteCharAt, insert etc
iii) count sort for frequency count
iv) Anagram
v) sorting
vi) partition using Recursion
vii) Trie, hashmap
viii) Rolling hash, KMP, Z-algorithm
ix) LPS(longest prefix suffix) array
x) Recursion 
xi) backtracking
xii) removing duplicate(we can avoid processing it) by sorting
xiii) if you can replace only 1 char, then storing the frequency and comparison of two 
      strings wont work here unless permutation is allowed[eg- lest and lose] replace t with e
      and count frequency it will return true(both matching) but without permutation it wont match

count array size:
xiv) a-z [26], ascii [128], unicode[256]

xix) if you are getting tle in recursive question , maybe u need to store intermediate results using hashmap

------------------
6) BACKTRACKING
------------------
i) DFS
ii) some word search matrix problems
iii) finding subsets, all possibilities 
iv) in problems like word search II , instead of creating visited matrix,
     you can modify the data of the mat[x][y] temporarily to make it act as a visited matrix
     to some value like 0/ # which are not being used 


------------------
7) QUEUE
------------------
1) to process data in some order
2) to avoid keeping pointers (to keep track of unprocessd data)
3) to deserialize binary tree (it avoids keeping pointers by removing processed data)
4) BFS (level by level visit)


------------------
8) BFS
------------------
1) when you need to find shortest path
2) snake and ladder
3) level order traversal


------------------
9) Numbers
------------------
1) Extra attention to leading zeroes
2) when dealing with strings (check invalid inputs) to integer
3) sieve of eratothenis, segmented sieve, lcm, gcd
4) modulo operation 
5) some bitmasking techniques(set bit,remove bit etc)
6) a % b (always check b cant be 0)
7) ap,gp, number theory formulas will help


------------------
10) DP / memoization
------------------
1) look for variables which are changing after every call 
2) you can memoize these variables
3) if you are adding some value to the returned function then(dont return Integer.MAX/MIN_VALUE)
   because it will cause overflow and you will get wrong answer
   you can return (Integer.MIN/MAX_VALUE) /2 or similar to it


------------------
11) Substring / subarray type of questions
------------------
i) you can think of modifying kaden's algorithm (eg keywords-> maxSofar, longest, count array, reset when fails)
ii) brute force sliding window
iii) optimized sliding window (generally in linear time), maybe by using two poiters
iv) character mapping using hashmap or array 

------------------
12) Sliding Window
------------------
i) questions like longest/smallest substring with variations



https://leetcode.com/problems/minimum-window-substring/discuss/26808/Here-is-a-10-line-template-that-can-solve-most-'substring'-problems